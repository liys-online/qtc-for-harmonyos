#include "harmonyutils.h"

#include "harmonyconfigurations.h"
#include "harmonyqtversion.h"
#include "ohosconstants.h"
#include "ohprojectecreator/ohprojectecreator.h"
#include <cmakeprojectmanager/cmakeprojectconstants.h>
#include <coreplugin/icontext.h>
#include <projectexplorer/buildconfiguration.h>
#include <projectexplorer/buildsystem.h>
#include <projectexplorer/project.h>
#include <projectexplorer/projectnodes.h>

#include <qjsonarray.h>
#include <qtsupport/qtkitaspect.h>
#include <utils/qtcprocess.h>
#include <QLoggingCategory>
#include <QJsonDocument>
#include <QJsonObject>
using namespace ProjectExplorer;
using namespace Utils;
namespace Ohos::Internal {
const char HarmonyAppJson5Name[] = "app.json5";
const char HarmonyDeviceSn[] = "HarmonyDeviceSerialNumber";
const char HarmonyDeviceAbis[] = "HarmonyDeviceAbis";
const char ApiLevelKey[] = "HarmonyVersion.ApiLevel";
const char qtcSignature[] = "This file is generated by QtCreator to be read by "
                            "harmonydeployqt and should not be modified by hand.";

static Q_LOGGING_CATEGORY(harmonyManagerLog, "qtc.harmony.harmonyManager", QtWarningMsg)

bool openDevEcoProject(const QString &path)
{
    Utils::FilePath devecostudioExe = HarmonyConfig::devecostudioExeLocation();
    if (!devecostudioExe.isExecutableFile())
        return false;
    const Utils::CommandLine command{devecostudioExe, {path}};
    return Utils::Process::startDetached(command);
}

QStringList applicationAbis(const ProjectExplorer::Kit *k)
{
    const auto *qt = dynamic_cast<HarmonyQtVersion *>(QtSupport::QtKitAspect::qtVersion(k));
    return qt ? qt->ohosAbis() : QStringList();
}

QStringList hdcSelector(const QString &serialNumber)
{
    // if (serialNumber.startsWith(QLatin1String("????")))
    //     return {"-d"};
    return {"-t", serialNumber};
}

static const ProjectNode *currentProjectNode(const BuildConfiguration *bc)
{
    return bc->project()->findNodeForBuildKey(bc->activeBuildKey());
}

QString packageName(const ProjectExplorer::BuildConfiguration *bc)
{
    QString packageName;
    const FilePath harmonyBuildDir = harmonyBuildDirectory(bc);
    const Result<QByteArray> appJsonContents = harmonyBuildDir.pathAppended("AppScope/app.json5")
                                                  .fileContents();
    if (appJsonContents) {
        QJsonObject rootJson = QJsonDocument::fromJson(*appJsonContents).object();
        auto appObject = rootJson.value("app").toObject();
        packageName = appObject.value("bundleName").toString();
    }
    return packageName;
}

Utils::FilePath harmonyBuildDirectory(const ProjectExplorer::BuildConfiguration *bc)
{
    QString suffix;
    const ProjectExplorer::Project *project = bc->project();
    if (project->extraData(Ohos::Constants::HarmonyBuildTargetDirSupport).toBool()
        && project->extraData(Ohos::Constants::UseHarmonyBuildTargetDir).toBool())
        suffix = QString("-%1").arg(bc->activeBuildKey());

    return buildDirectory(bc) / (Constants::HARMONY_BUILD_DIRECTORY + suffix);
}

Utils::FilePath buildDirectory(const ProjectExplorer::BuildConfiguration *bc)
{
    const QString buildKey = bc->activeBuildKey();

    // Get the target build dir based on the settings file path
    FilePath buildDir;
    const ProjectNode *node = bc->project()->findNodeForBuildKey(buildKey);
    if (node) {
        const QString settingsFile = node->data(Constants::HarmonyDeploySettingsFile).toString();
        buildDir = FilePath::fromUserInput(settingsFile).parentDir();
    }

    if (!buildDir.isEmpty())
        return buildDir;

    // Otherwise fallback to target working dir
    buildDir = bc->buildDirectory();
    return buildDir;
}

bool isQt5CmakeProject(const ProjectExplorer::Target *target)
{
    const QtSupport::QtVersion *qt = QtSupport::QtKitAspect::qtVersion(target->kit());
    const bool isQt5 = qt && qt->qtVersion() < QVersionNumber(6, 0, 0);
    const Core::Context cmakeCtx(CMakeProjectManager::Constants::CMAKE_PROJECT_ID);
    const bool isCmakeProject = (target->project()->projectContext() == cmakeCtx);
    return isQt5 && isCmakeProject;
}

QString deviceSerialNumber(const ProjectExplorer::BuildConfiguration *bc)
{
    return bc->extraData(HarmonyDeviceSn).toString();
}

void setDeviceSerialNumber(ProjectExplorer::BuildConfiguration *bc, const QString &deviceSerialNumber)
{
    qCDebug(harmonyManagerLog) << "Target device serial changed:"
                               << bc->target()->displayName() << deviceSerialNumber;
    bc->setExtraData(HarmonyDeviceSn, deviceSerialNumber);
}
static QString preferredAbi(const QStringList &appAbis, const BuildConfiguration *bc)
{
    const auto deviceAbis = bc->extraData(HarmonyDeviceAbis).toStringList();

    return Utils::findOrDefault(deviceAbis,[appAbis](const auto &abi) { return appAbis.contains(abi); });
}
QString hapDevicePreferredAbi(const ProjectExplorer::BuildConfiguration *bc)
{
    const FilePath libsPath = harmonyBuildDirectory(bc).pathAppended("entry/libs");
    if (!libsPath.exists()) {
        if (const ProjectNode *node = currentProjectNode(bc)) {
            const QString abi = preferredAbi(
                node->data(Ohos::Constants::HarmonyAbis).toStringList(), bc);
            if (abi.isEmpty())
                return node->data(Ohos::Constants::OHOS_ARCH).toString();
        }
    }
    QStringList apkAbis;
    const FilePaths libsPaths = libsPath.dirEntries(QDir::Dirs | QDir::NoDotAndDotDot);
    for (const FilePath &abiDir : libsPaths) {
        if (!abiDir.dirEntries({{"*.so"}, QDir::Files | QDir::NoDotAndDotDot}).isEmpty())
            apkAbis << abiDir.fileName();
    }
    return preferredAbi(apkAbis, bc);
}

void setDeviceAbis(ProjectExplorer::BuildConfiguration *bc, const QStringList &deviceAbis)
{
    bc->setExtraData(HarmonyDeviceAbis, deviceAbis);
}

int deviceApiLevel(const ProjectExplorer::BuildConfiguration *bc)
{
    return bc->extraData(ApiLevelKey).toInt();
}

void setDeviceApiLevel(ProjectExplorer::BuildConfiguration *bc, int level)
{
    qCDebug(harmonyManagerLog) << "Target device API level changed:"
                               << bc->target()->displayName() << level;
    bc->setExtraData(ApiLevelKey, level);
}

FilePath appJson5Path(const ProjectExplorer::BuildConfiguration *bc)
{
    QVariant manifest = bc->extraData(HarmonyAppJson5Name);
    if (manifest.isValid())
        return manifest.value<FilePath>();
    return harmonyBuildDirectory(bc).pathAppended(HarmonyAppJson5Name);
}

void setAppJson5Path(ProjectExplorer::BuildConfiguration *bc, const Utils::FilePath &path)
{
    bc->setExtraData(HarmonyAppJson5Name, QVariant::fromValue(path));
}
static int parseMinSdk(const FilePath &appJson5Path)
{
    const Result<QByteArray> appJsonContents = appJson5Path.fileContents();
    if (!appJsonContents) {
        qCWarning(harmonyManagerLog) << "Failed to read" << appJson5Path;
        return 0;
    }
    QJsonObject rootJson = QJsonDocument::fromJson(*appJsonContents).object();
    auto productsArray = rootJson.value("products").toArray();
    int minSdkVersion = OhProjecteCreator::latestApiLevel();
    for (const auto &productValue : std::as_const(productsArray)) {
        auto productObject = productValue.toObject();
        QString compatibleSdkVersion = productObject.value("compatibleSdkVersion").toString();
        minSdkVersion = qMin(minSdkVersion, OhProjecteCreator::apiLevelForVersion(compatibleSdkVersion));
    }
    return minSdkVersion;
}

int minimumSDK(const ProjectExplorer::BuildConfiguration *bc)
{
    const auto buildProfile = harmonyBuildDirectory(bc).pathAppended("build-profile.json5");
    if (!buildProfile.exists())
        return minimumSDK(bc->kit());

    const int minSdkVersion = parseMinSdk(buildProfile);
    if (minSdkVersion == 0)
        return defaultMinimumSDK(QtSupport::QtKitAspect::qtVersion(bc->kit()));
    return minSdkVersion;
}

int minimumSDK(const ProjectExplorer::Kit *kit)
{
    int minSdkVersion = -1;
    QtSupport::QtVersion *version = QtSupport::QtKitAspect::qtVersion(kit);
    if (version && version->targetDeviceTypes().contains(Constants::HARMONY_DEVICE_TYPE)) {
        auto harmonyQt = dynamic_cast<const HarmonyQtVersion *>(version);

        if (harmonyQt)
            minSdkVersion = harmonyQt->supportOhVersion().majorVersion();
    }
    if (minSdkVersion == 0)
        return defaultMinimumSDK(version);
    return minSdkVersion;
}

int defaultMinimumSDK(const QtSupport::QtVersion *qtVersion)
{
    auto harmonyQt = dynamic_cast<const HarmonyQtVersion *>(qtVersion);
    if (harmonyQt)
        return harmonyQt->supportOhVersion().majorVersion();
    return OhProjecteCreator::defaultApiLevel();
}

}
